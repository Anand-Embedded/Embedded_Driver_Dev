/*
 * stm32f407xx_i2c_driver.c
 *
 *  Created on: Sep 26, 2021
 *      Author: Admin
 */

#include "stm32f4xx.h"

static void I2C_StartCondition(I2C_RegDef_t *pI2Cx);
static void I2C_StopCondition(I2C_RegDef_t *pI2Cx);
static void I2C_AddressPhaseWrite(I2C_RegDef_t *pI2Cx,uint8_t SlaveAddress);
static void I2C_AddressPhaseRead(I2C_RegDef_t *pI2Cx,uint8_t SlaveAddress);
static void I2C_ClearAddressPhase(I2C_RegDef_t *pI2Cx);


/*
 * Peripheral clock enable or disable API
 */
void I2C_PeriClock_Control(I2C_RegDef_t *pI2Cx,uint8_t EnorDi)
{
	if(EnorDi == ENABLE)
	{
		if(pI2Cx == I2C1)
		{
			I2C1_PCLK_EN();
		}
		else if(pI2Cx == I2C2)
		{
			I2C2_PCLK_EN();
		}
		else if(pI2Cx == I2C3)
		{
			I2C3_PCLK_EN();
		}
	}
	else
	{
		if(pI2Cx == I2C1)
		{
			I2C1_PCLK_DI();
		}
		else if(pI2Cx == I2C2)
		{
			I2C2_PCLK_DI();
		}
		else if(pI2Cx == I2C3)
		{
			I2C3_PCLK_DI();
		}
	}
}

uint32_t GetPLLClockOutput(void)
{
	//TODO
}

uint16_t AHB_Prescalar[] = {2,4,8,16,32,64,128,256,512};
uint8_t APB1_Prescalar[] = {2,4,8,16};
uint32_t GetPCLKValue(void)
{
	uint32_t SystemClock = 0;
	uint32_t PCLK = 0;
	uint8_t ClockSource = 0;
	uint8_t AHBprescalarIndex = 0;
	uint8_t APB1prescalarIndex = 0;
	uint16_t AHBPrescValue = 0;
	uint8_t APB1PrescValue = 0;

	ClockSource = (RCC->CFGR >> 2) & 0x03;

	if( ClockSource == 0)
	{
		//HSI
		SystemClock = 16000000;
	}
	else if( ClockSource == 1)
	{
		//HSE
		SystemClock = 8000000;
	}
	else if( ClockSource == 2)
	{
		//PLL
		SystemClock = GetPLLClockOutput();
	}

	AHBprescalarIndex = (RCC->CFGR >> 4) & 0xF;
	if(AHBprescalarIndex == 0)
	{
		AHBPrescValue = 1;
	}
	else
	{
		AHBPrescValue = AHB_Prescalar[AHBprescalarIndex - 8];
	}

	APB1prescalarIndex = (RCC->CFGR >> 10) & 0x7;
	if(APB1prescalarIndex == 0)
	{
		APB1PrescValue = 1;
	}
	else
	{
		APB1PrescValue = APB1_Prescalar[APB1prescalarIndex - 4];
	}

	PCLK = ((SystemClock / AHBPrescValue) / APB1PrescValue) ;

	return PCLK;

}



/*
 * I2Cx init and De-init function
 */
void I2C_Init(I2C_Handle_t *pI2CHandle)
{
	uint32_t tempreg = 0;
	uint32_t APBCLK = 0;

	I2C_PeriClock_Control(pI2CHandle->pI2Cx, ENABLE);

	//Enable the automatic ACKing in I2C hardware
	tempreg |= (pI2CHandle->pI2C_Config.I2C_ACKCtrl << I2C_CR1_ACK);
	pI2CHandle->pI2Cx->CR1 |= tempreg;
	tempreg = 0;

	//Configure the OWN address , this will be used when I2C act as slave
	tempreg |= (pI2CHandle->pI2C_Config.I2C_DeviceAddr << 1);
	tempreg |= (1 << 14);//this is reserved bit and set as per RM
	pI2CHandle->pI2Cx->OAR1 |= tempreg;
	tempreg = 0;

	APBCLK = GetPCLKValue() / 1000000U; //16000000/1000000 =>16

	if(APBCLK <= 1)
	{
		APBCLK = 2;
	}
	//Configure the I2C frequency
	pI2CHandle->pI2Cx->CR2 = (APBCLK & 0x3F);


	if(pI2CHandle->pI2C_Config.I2C_SCLSpeed <= I2C_SPEED_STD_MODE)
	{

		//Sm mode or SMBus:
		//Thigh = CCR * TPCLK1
		//Tlow = CCR * TPCLK1

		tempreg |= (GetPCLKValue() / (2 * pI2CHandle->pI2C_Config.I2C_SCLSpeed));
	}
	else
	{
		//Fast mode
		tempreg |= (1 << I2C_CCR_FS);
		//Configure duty cycle
		tempreg |= (pI2CHandle->pI2C_Config.I2C_FMDutyCycle << I2C_CCR_DUTY);
		//Duty = 0
		if(pI2CHandle->pI2C_Config.I2C_FMDutyCycle == I2C_FM_DUTY_2)
		{
			//Fm mode:
			//If DUTY = 0:
			//Thigh = CCR * TPCLK1
			//Tlow = 2 * CCR * TPCLK1
			//Tlow = 2 * Thigh

			tempreg |= (GetPCLKValue() / (3 * pI2CHandle->pI2C_Config.I2C_SCLSpeed));

		}
		else
		{
			//Duty = 1
			//If DUTY = 1: (to reach 400 kHz)
			//Thigh = 9 * CCR * TPCLK1
			//Tlow = 16 * CCR * TPCLK1
			tempreg |= (GetPCLKValue() / (25 * pI2CHandle->pI2C_Config.I2C_SCLSpeed));
		}
	}
	pI2CHandle->pI2Cx->CCR |= (tempreg & 0xFFF);
	tempreg = 0;

	//Configure the Trise value
	if(pI2CHandle->pI2C_Config.I2C_SCLSpeed <= I2C_SPEED_STD_MODE)
	{
		// Standard mode as per I2C spec trise for SM is 1000ns
		tempreg |= ((GetPCLKValue() * 1) / 1000000U)  + 1;
	}
	else
	{
		//fast mode as per I2C spec trise is 300ns
		tempreg |= ((GetPCLKValue() * 300) / 1000000000U)  + 1;
	}

	pI2CHandle->pI2Cx->TRISE |= (tempreg & 0x3F);
}


/*
 * I2C send and receive data
 */
void I2C_MasterSenddata(I2C_RegDef_t *pI2Cx,uint8_t *pTxBuffer,uint32_t Len, uint8_t SlaveAddress)
{
	//Start condition iss generated by master
	I2C_StartCondition(pI2Cx);

	//to clear the start condition event and write the address phase
	while(!(I2C_GetFlagStatus(pI2Cx, I2C_FLAG_SB)));

	// write the address phase
	I2C_AddressPhaseWrite(pI2Cx,SlaveAddress);

	//to clear the address ADDR =1 , read the SR1 and SR2
	while(!(I2C_GetFlagStatus(pI2Cx, I2C_FLAG_ADDR)));
	I2C_ClearAddressPhase(pI2Cx);

	//write data into slave
	while(Len > 0)
	{
		while(!(I2C_GetFlagStatus(pI2Cx, I2C_FLAG_TXE)));
		pI2Cx->DR = *pTxBuffer;
		pTxBuffer++;
		Len--;
	}

	//wait for TXE =1 AND BTF =1
	while(!(I2C_GetFlagStatus(pI2Cx, I2C_FLAG_TXE)));
	while(!(I2C_GetFlagStatus(pI2Cx, I2C_FLAG_BTF)));


	//generate the stop condition
	I2C_StopCondition(pI2Cx);

}


void I2C_MasterReceivedata(I2C_RegDef_t *pI2Cx,uint8_t *pRxBuffer,uint32_t Len, uint8_t SlaveAddress)
{
	//Generate the start condition
	I2C_StartCondition(pI2Cx);

	//Read the SB bit from 12C SR1 to clear the Event
	while(!(I2C_GetFlagStatus(pI2Cx, I2C_FLAG_SB)));

	//I2C Address phase read
	I2C_AddressPhaseRead(pI2Cx,SlaveAddress);

	//1 byte transmission
	if(Len == 1)
	{
		//Disable the ACK bit, so Master wont send ACK to slave this confirms the from the master that slave
		//wont proceed to send further bytes

	}

	//N byte's transmission
	if ( Len > 1)
	{

	}

}

void I2C_StartCondition(I2C_RegDef_t *pI2Cx)
{
	pI2Cx->CR1 |= ( 1 << I2C_CR1_START);
}


void I2C_StopCondition(I2C_RegDef_t *pI2Cx)
{
	pI2Cx->CR1 |= ( 1 << I2C_CR1_STOP);
}

/*
 * I2C Get Status API's
 */
uint8_t I2C_GetFlagStatus(I2C_RegDef_t *pI2Cx,uint32_t flagread)
{
	if(pI2Cx->SR1 & flagread)
	{
		return 1;
	}
	return 0;
}


void I2C_AddressPhaseWrite(I2C_RegDef_t *pI2Cx,uint8_t SlaveAddress)
{
	uint8_t tempreg = 0;
	tempreg |= ( SlaveAddress << 1);
	tempreg &= ~(1);	// Write operation bit is set in I2C slave address
	pI2Cx->DR = tempreg;
}

void I2C_AddressPhaseRead(I2C_RegDef_t *pI2Cx,uint8_t SlaveAddress)
{
	uint8_t tempreg = 0;
	tempreg |= ( SlaveAddress << 1);
	tempreg |= (1 << 0);// Read bit is set in slave address
	pI2Cx->DR = tempreg;
}


void I2C_ClearAddressPhase(I2C_RegDef_t *pI2Cx)
{
	uint8_t tempreg = 0;
	tempreg = pI2Cx->SR1;
	tempreg = pI2Cx->SR2;
	(void)tempreg;
}

void I2C_ManageACK(I2C_RegDef_t *pI2Cx,uint8_t EnorDi)
{
	if(EnorDi == ENABLE)
	{
		pI2Cx->CR1 |= (1 << I2C_CR1_ACK);
	}
	else
	{

	}
}

void I2C_DeInit(I2C_RegDef_t *pI2Cx)
{
	if(pI2Cx == I2C1)
	{
		I2C1_REG_RST();
	}
	else if(pI2Cx == I2C2)
	{
		I2C2_REG_RST();
	}
	else if(pI2Cx == I2C3)
	{
		I2C3_REG_RST();
	}
}


void I2C_PeripheralControl(I2C_RegDef_t *pI2Cx,uint8_t EnorDi)
{
	if(EnorDi ==  ENABLE)
	{
		pI2Cx->CR1 |= (1 << I2C_CR1_PE);
	}
	else
	{
		pI2Cx->CR1 &= ~(1 << I2C_CR1_PE);
	}
}
