/*
 * stm32f407xx_i2c_driver.c
 *
 *  Created on: Sep 26, 2021
 *      Author: Admin
 */

#include "stm32f4xx.h"

static void I2C_StartCondition(I2C_RegDef_t *pI2Cx);
static void I2C_StopCondition(I2C_RegDef_t *pI2Cx);
static void I2C_ExecuteAddressPhaseWrite(I2C_RegDef_t *pI2Cx,uint8_t SlaveAddress);
static void I2C_ExecuteAddressPhaseRead(I2C_RegDef_t *pI2Cx,uint8_t SlaveAddress);
static void I2C_ClearAddressPhase(I2C_Handle_t *pI2CHandle);
static void I2C_InterruptHandling_TXECallback(I2C_Handle_t *pI2CHandle);
static void I2C_InterruptHandling_RXNECallback(I2C_Handle_t *pI2CHandle);



/*
 * Peripheral clock enable or disable API
 */
void I2C_PeriClock_Control(I2C_RegDef_t *pI2Cx,uint8_t EnorDi)
{
	if(EnorDi == ENABLE)
	{
		if(pI2Cx == I2C1)
		{
			I2C1_PCLK_EN();
		}
		else if(pI2Cx == I2C2)
		{
			I2C2_PCLK_EN();
		}
		else if(pI2Cx == I2C3)
		{
			I2C3_PCLK_EN();
		}
	}
	else
	{
		if(pI2Cx == I2C1)
		{
			I2C1_PCLK_DI();
		}
		else if(pI2Cx == I2C2)
		{
			I2C2_PCLK_DI();
		}
		else if(pI2Cx == I2C3)
		{
			I2C3_PCLK_DI();
		}
	}
}

uint32_t GetPLLClockOutput(void)
{
	//TODO
}

uint16_t AHB_Prescalar[] = {2,4,8,16,32,64,128,256,512};
uint8_t APB1_Prescalar[] = {2,4,8,16};
uint32_t GetPCLKValue(void)
{
	uint32_t SystemClock = 0;
	uint32_t PCLK = 0;
	uint8_t ClockSource = 0;
	uint8_t AHBprescalarIndex = 0;
	uint8_t APB1prescalarIndex = 0;
	uint16_t AHBPrescValue = 0;
	uint8_t APB1PrescValue = 0;

	ClockSource = (RCC->CFGR >> 2) & 0x03;

	if( ClockSource == 0)
	{
		//HSI
		SystemClock = 16000000;
	}
	else if( ClockSource == 1)
	{
		//HSE
		SystemClock = 8000000;
	}
	else if( ClockSource == 2)
	{
		//PLL
		SystemClock = GetPLLClockOutput();
	}

	AHBprescalarIndex = (RCC->CFGR >> 4) & 0xF;
	if(AHBprescalarIndex == 0)
	{
		AHBPrescValue = 1;
	}
	else
	{
		AHBPrescValue = AHB_Prescalar[AHBprescalarIndex - 8];
	}

	APB1prescalarIndex = (RCC->CFGR >> 10) & 0x7;
	if(APB1prescalarIndex == 0)
	{
		APB1PrescValue = 1;
	}
	else
	{
		APB1PrescValue = APB1_Prescalar[APB1prescalarIndex - 4];
	}

	PCLK = ((SystemClock / AHBPrescValue) / APB1PrescValue) ;

	return PCLK;

}



/*
 * I2Cx init and De-init function
 */
void I2C_Init(I2C_Handle_t *pI2CHandle)
{
	uint32_t tempreg = 0;
	uint32_t APBCLK = 0;

	I2C_PeriClock_Control(pI2CHandle->pI2Cx, ENABLE);

	//Enable the automatic ACKing in I2C hardware
	tempreg |= (pI2CHandle->pI2C_Config.I2C_ACKCtrl << I2C_CR1_ACK);
	pI2CHandle->pI2Cx->CR1 |= tempreg;
	tempreg = 0;

	//Configure the OWN address , this will be used when I2C act as slave
	tempreg |= (pI2CHandle->pI2C_Config.I2C_DeviceAddr << 1);
	tempreg |= (1 << 14);//this is reserved bit and set as per RM
	pI2CHandle->pI2Cx->OAR1 |= tempreg;
	tempreg = 0;

	APBCLK = GetPCLKValue() / 1000000U; //16000000/1000000 =>16

	if(APBCLK <= 1)
	{
		APBCLK = 2;
	}
	//Configure the I2C frequency
	pI2CHandle->pI2Cx->CR2 = (APBCLK & 0x3F);


	if(pI2CHandle->pI2C_Config.I2C_SCLSpeed <= I2C_SPEED_STD_MODE)
	{

		//Sm mode or SMBus:
		//Thigh = CCR * TPCLK1
		//Tlow = CCR * TPCLK1

		tempreg |= (GetPCLKValue() / (2 * pI2CHandle->pI2C_Config.I2C_SCLSpeed));
	}
	else
	{
		//Fast mode
		tempreg |= (1 << I2C_CCR_FS);
		//Configure duty cycle
		tempreg |= (pI2CHandle->pI2C_Config.I2C_FMDutyCycle << I2C_CCR_DUTY);
		//Duty = 0
		if(pI2CHandle->pI2C_Config.I2C_FMDutyCycle == I2C_FM_DUTY_2)
		{
			//Fm mode:
			//If DUTY = 0:
			//Thigh = CCR * TPCLK1
			//Tlow = 2 * CCR * TPCLK1
			//Tlow = 2 * Thigh

			tempreg |= (GetPCLKValue() / (3 * pI2CHandle->pI2C_Config.I2C_SCLSpeed));

		}
		else
		{
			//Duty = 1
			//If DUTY = 1: (to reach 400 kHz)
			//Thigh = 9 * CCR * TPCLK1
			//Tlow = 16 * CCR * TPCLK1
			tempreg |= (GetPCLKValue() / (25 * pI2CHandle->pI2C_Config.I2C_SCLSpeed));
		}
	}
	pI2CHandle->pI2Cx->CCR |= (tempreg & 0xFFF);
	tempreg = 0;

	//Configure the Trise value
	if(pI2CHandle->pI2C_Config.I2C_SCLSpeed <= I2C_SPEED_STD_MODE)
	{
		// Standard mode as per I2C spec trise for SM is 1000ns
		tempreg |= ((GetPCLKValue() * 1) / 1000000U)  + 1;
	}
	else
	{
		//fast mode as per I2C spec trise is 300ns
		tempreg |= ((GetPCLKValue() * 300) / 1000000000U)  + 1;
	}

	pI2CHandle->pI2Cx->TRISE |= (tempreg & 0x3F);
}


/*
 * I2C send and receive data
 */
void I2C_MasterSenddata(I2C_Handle_t *pI2CHandle,uint8_t *pTxBuffer,uint32_t Len, uint8_t SlaveAddress,uint8_t RepeatedStart)
{
	//Start condition iss generated by master
	I2C_StartCondition(pI2CHandle->pI2Cx);

	//to clear the start condition event and write the address phase
	while(!(I2C_GetFlagStatus(pI2CHandle->pI2Cx, I2C_FLAG_SB)));

	// write the address phase
	I2C_ExecuteAddressPhaseWrite(pI2CHandle->pI2Cx,SlaveAddress);

	//to clear the address ADDR =1 , read the SR1 and SR2
	while(!(I2C_GetFlagStatus(pI2CHandle->pI2Cx, I2C_FLAG_ADDR)));
	I2C_ClearAddressPhase(pI2CHandle);

	//write data into slave
	while(Len > 0)
	{
		while(!(I2C_GetFlagStatus(pI2CHandle->pI2Cx, I2C_FLAG_TXE)));
		pI2CHandle->pI2Cx->DR = *pTxBuffer;
		pTxBuffer++;
		Len--;
	}

	//wait for TXE =1 AND BTF =1
	while(!(I2C_GetFlagStatus(pI2CHandle->pI2Cx, I2C_FLAG_TXE)));
	while(!(I2C_GetFlagStatus(pI2CHandle->pI2Cx, I2C_FLAG_BTF)));

	if(RepeatedStart == REPEATED_START_DISABLE)
	{
		//generate the stop condition
		I2C_StopCondition(pI2CHandle->pI2Cx);
	}

}


void I2C_MasterReceivedata(I2C_Handle_t *pI2CHandle,uint8_t *pRxBuffer,uint32_t Len, uint8_t SlaveAddress,uint8_t RepeatedStart)
{
	//Generate the start condition
	I2C_StartCondition(pI2CHandle->pI2Cx);

	//Read the SB bit from 12C SR1 to clear the Event
	while(!(I2C_GetFlagStatus(pI2CHandle->pI2Cx, I2C_FLAG_SB)));

	//I2C Address phase read
	I2C_ExecuteAddressPhaseRead(pI2CHandle->pI2Cx,SlaveAddress);

	//to clear the address ADDR =1 , read the SR1 and SR2
	while(!(I2C_GetFlagStatus(pI2CHandle->pI2Cx, I2C_FLAG_ADDR)));

	//1 byte transmission
	if(Len == 1)
	{
		//Disable the ACK bit, so Master wont send ACK to slave this confirms the from the master that slave
		//wont proceed to send further bytes
		I2C_ManageACK(pI2CHandle->pI2Cx, DISABLE);

		//Clear the Address phase
		I2C_ClearAddressPhase(pI2CHandle);

		//Wait until RXNE bit is set
		while(!(I2C_GetFlagStatus(pI2CHandle->pI2Cx, I2C_FLAG_RXNE)));

		if(RepeatedStart == REPEATED_START_DISABLE)
		{
			//Generate the I2C stop condition
			I2C_StopCondition(pI2CHandle->pI2Cx);
		}

		//Read the Data
		*pRxBuffer = pI2CHandle->pI2Cx->DR;
	}

	//N byte's transmission
	if ( Len > 1)
	{
		//Clear the Address phase so master release the SCL line for further transaction
		I2C_ClearAddressPhase(pI2CHandle);

		for(uint32_t i = Len; i > 0;i--)
		{

			//Wait until RXNE bit is set
			while(!(I2C_GetFlagStatus(pI2CHandle->pI2Cx, I2C_FLAG_RXNE)));

			if (i == 2)
			{
				//Disable the ACK bit, so Master wont send ACK to slave this confirms the from the master that slave
				//wont proceed to send further bytes
				I2C_ManageACK(pI2CHandle->pI2Cx, DISABLE);

				//Used to generate  the Repeated start
				if(RepeatedStart == REPEATED_START_DISABLE)
				{
					//Generate the I2C stop condition
					I2C_StopCondition(pI2CHandle->pI2Cx);
				}

			}
			//Read the Data
			*pRxBuffer = pI2CHandle->pI2Cx->DR;
			pRxBuffer++;

			//Decrement the length byte by one
			Len--;
		}
	}

	//IF User mentioned as enable in configuration
	if(pI2CHandle->pI2C_Config.I2C_ACKCtrl == I2C_ACK_ENABLE)
	{
		I2C_ManageACK(pI2CHandle->pI2Cx, ENABLE);
	}

}

I2C_State_e I2C_MasterSenddataIT(I2C_Handle_t *pI2CHandle,uint8_t *pTxBuffer,uint32_t Len, uint8_t SlaveAddress,uint8_t RepeatedStart)
{
	I2C_State_e state = pI2CHandle->TxRxState;

	if( (state != I2C_STATE_BUSY_IN_TX) && (state != I2C_STATE_BUSY_IN_RX))
	{
		pI2CHandle->pTxBuffer = pTxBuffer ;
		pI2CHandle->TxLen = Len;
		pI2CHandle->TxRxState = I2C_STATE_BUSY_IN_TX;
		pI2CHandle->Device_Addr = SlaveAddress;
		pI2CHandle->Repeated_Start = RepeatedStart;

		//Generate the start condition
		I2C_StartCondition(pI2CHandle->pI2Cx);


		//Enable ITBUFEN Control Bit
		pI2CHandle->pI2Cx->CR2 |= ( 1 << I2C_CR2_ITBUFEN);

		//Enable ITEVFEN Control Bit
		pI2CHandle->pI2Cx->CR2 |= ( 1 << I2C_CR2_ITEVTEN);

		//Enable ITERREN Control Bit
		pI2CHandle->pI2Cx->CR2 |= ( 1 << I2C_CR2_ITERREN);

	}

	return state;
}


I2C_State_e I2C_MasterReceivedataIT(I2C_Handle_t *pI2CHandle,uint8_t *pRxBuffer,uint32_t Len, uint8_t SlaveAddress,uint8_t RepeatedStart)
{
	I2C_State_e state = pI2CHandle->TxRxState;

	if( (state != I2C_STATE_BUSY_IN_TX) && (state != I2C_STATE_BUSY_IN_RX))
	{
		pI2CHandle->pRxBuffer = pRxBuffer ;
		pI2CHandle->RxLen = Len;
		pI2CHandle->TxRxState = I2C_STATE_BUSY_IN_RX;
		pI2CHandle->RxSize = Len;
		pI2CHandle->Device_Addr = SlaveAddress;
		pI2CHandle->Repeated_Start = RepeatedStart;

		//Generate the start condition
		I2C_StartCondition(pI2CHandle->pI2Cx);


		//Enable ITBUFEN Control Bit
		pI2CHandle->pI2Cx->CR2 |= ( 1 << I2C_CR2_ITBUFEN);

		//Enable ITEVFEN Control Bit
		pI2CHandle->pI2Cx->CR2 |= ( 1 << I2C_CR2_ITEVTEN);

		//Enable ITERREN Control Bit
		pI2CHandle->pI2Cx->CR2 |= ( 1 << I2C_CR2_ITERREN);

	}

	return state;
}



void I2C_Event_IRQHandling(I2C_Handle_t *pI2CHandle)
{
	uint32_t temp1, temp2 , temp3 = 0;

	//Read the I2C interrupt I2C_CR2_ITEVTEN for Start , stop , ADDR event
	temp1 = (pI2CHandle->pI2Cx->CR2 & (1 << I2C_CR2_ITEVTEN)) ;

	//Read the I2C interrupt I2C_CR2_ITBUFEN for TXE and RXNE
	temp2 = (pI2CHandle->pI2Cx->CR2   & (1 <<  I2C_CR2_ITBUFEN));

	//Read the I2C status register for SB
	temp3 = (pI2CHandle->pI2Cx->SR1  & (1 <<  I2C_SR1_SB));
	if(temp3 && temp1)
	{
		//Execute the Address phase and To clear the address phase need to read the  SR1 followed by SR2
		if(pI2CHandle->TxRxState == I2C_STATE_BUSY_IN_TX)
		{
			I2C_ExecuteAddressPhaseWrite(pI2CHandle->pI2Cx, pI2CHandle->Device_Addr);
		}
		else if(pI2CHandle->TxRxState == I2C_STATE_BUSY_IN_RX)
		{
			I2C_ExecuteAddressPhaseRead(pI2CHandle->pI2Cx, pI2CHandle->Device_Addr);
		}
	}

	//Read the I2C status register for ADDR
	temp3 = (pI2CHandle->pI2Cx->SR1 & (1 <<  I2C_SR1_ADDR));
	if(temp3 && temp1)
	{
		//Clear the Address phase
		I2C_ClearAddressPhase(pI2CHandle);
	}


	//Read the I2C status register for BTF
	temp3 = (pI2CHandle->pI2Cx->SR1  & (1 <<  I2C_SR1_BTF));
	if(temp3 && temp1)
	{
		//Check whether I2C is in master mode
		if( pI2CHandle->pI2Cx->SR2 & (1 << I2C_SR2_MSL))
		{
			//BTF flag in TX ,Data register and Shift register is empty then BTF=1;
			if(pI2CHandle->TxRxState == I2C_STATE_BUSY_IN_TX)
			{
				if(pI2CHandle->TxLen == 0)
				{

					if(pI2CHandle->Repeated_Start == REPEATED_START_DISABLE)
						I2C_StopCondition(pI2CHandle->pI2Cx);

					//Close the I2C transmission
					I2C_CloseTranmission(pI2CHandle);

					I2C_ApplicationEventCallback(pI2CHandle, I2C_APP_EVT_TX_CMPLT);
					//printf(" I2C TX complt...\n");
				}
			}
		}
		else //I2C is in slave mode
		{

		}

	}

	//Read the I2C status register for STOPF
	temp3 = (pI2CHandle->pI2Cx->SR1  & (1 <<  I2C_SR1_STOPF));
	if(temp3 && temp1)
	{
		//Handle the stopf condition(slave mode)
		//Set by hardware when a Stop condition is detected on the bus by the slave after an
		//acknowledge (if ACK=1)

		//To clear the STOPF bit
		//read the SR1 followed by writing the CR1
		pI2CHandle->pI2Cx->CR1 |= 0x0000;

		I2C_ApplicationEventCallback(pI2CHandle, I2C_APP_EVT_STOP);
	}

	//Read the I2C status register for TXE
	temp3 = (pI2CHandle->pI2Cx->SR1 & (1 <<  I2C_SR1_TXE));
	if(temp3 && temp1 && temp2)
	{
		//Handle the txe bit
		//Handle the BTF completed for end of Transmission and reception
		//Check whether I2C is in master mode
		if( pI2CHandle->pI2Cx->SR2 & (1 << I2C_SR2_MSL))
		{
			I2C_InterruptHandling_TXECallback(pI2CHandle);
		}
		else //I2C is in slave mode
		{

		}
	}

	//Read the I2C status register for RXNE
	temp3 = (pI2CHandle->pI2Cx->SR1  & (1 <<  I2C_SR1_RXNE));
	if(temp3 && temp1 && temp2)
	{
		//Handle the RXNE bit
		//Check whether I2C is in master mode
		//if( pI2CHandle->pI2Cx->SR2 & (1 << I2C_SR2_MSL))
		{
			if(pI2CHandle->TxRxState ==I2C_STATE_BUSY_IN_RX)
			{
				I2C_InterruptHandling_RXNECallback(pI2CHandle);
			}
		}
		//else //I2C is in Slave mode
		{

		}
	}

}


void I2C_Error_IRQHandling(I2C_Handle_t *pI2CHandle)
{
	uint32_t temp1,temp2;

    //Know the status of  ITERREN control bit in the CR2
	temp2 = (pI2CHandle->pI2Cx->CR2) & ( 1 << I2C_CR2_ITERREN);


/***********************Check for Bus error************************************/
	temp1 = (pI2CHandle->pI2Cx->SR1) & ( 1<< I2C_SR1_BERR);
	if(temp1  && temp2 )
	{
		//This is Bus error

		//clear the buss error flag
		pI2CHandle->pI2Cx->SR1 &= ~( 1 << I2C_SR1_BERR);

		//Implement the code to notify the application about the error
	   I2C_ApplicationEventCallback(pI2CHandle,I2C_ERROR_BERR);
	}

/***********************Check for arbitration lost error************************************/
	temp1 = (pI2CHandle->pI2Cx->SR1) & ( 1 << I2C_SR1_ARLO );
	if(temp1  && temp2)
	{
		//This is arbitration lost error

		//Implement the code to clear the arbitration lost error flag
		//After an ARLO event the interface switches back automatically to Slave mode (MSL=0).
		//clear the buss error flag
		pI2CHandle->pI2Cx->SR1 &= ~( 1 << I2C_SR1_ARLO);

		//Implement the code to notify the application about the error
		I2C_ApplicationEventCallback(pI2CHandle,I2C_ERROR_ARLO);

	}

/***********************Check for ACK failure  error************************************/

	temp1 = (pI2CHandle->pI2Cx->SR1) & ( 1 << I2C_SR1_AF);
	if(temp1  && temp2)
	{
		//This is ACK failure error

	    //Implement the code to clear the ACK failure error flag
		pI2CHandle->pI2Cx->SR1 &= ~( 1 << I2C_SR1_AF);

		//Implement the code to notify the application about the error
		I2C_ApplicationEventCallback(pI2CHandle,I2C_ERROR_AF);

		//inside app event close the TX and generate STOP condition
		if(pI2CHandle->pI2C_Config.I2C_ACKCtrl == REPEATED_START_DISABLE)
		{
			I2C_StopCondition(pI2CHandle->pI2Cx);
		}
	}

/***********************Check for Overrun/underrun error************************************/
	temp1 = (pI2CHandle->pI2Cx->SR1) & ( 1 << I2C_SR1_OVR);
	if(temp1  && temp2)
	{
		//This is Overrun/underrun

	    //Implement the code to clear the Overrun/underrun error flag
		pI2CHandle->pI2Cx->SR1 &= ~( 1 << I2C_SR1_OVR);

		//Implement the code to notify the application about the error
		I2C_ApplicationEventCallback(pI2CHandle,I2C_ERROR_OVR);

		//Re-trasmission or reception based on state
		//inside app event close the TX and generate STOP condition
		if(pI2CHandle->pI2C_Config.I2C_ACKCtrl == REPEATED_START_DISABLE)
		{
			I2C_StopCondition(pI2CHandle->pI2Cx);
		}
	}

/***********************Check for Time out error************************************/
	temp1 = (pI2CHandle->pI2Cx->SR1) & ( 1 << I2C_SR1_TIMEOUT);
	if(temp1  && temp2)
	{
		//This is Time out error

	    //Implement the code to clear the Time out error flag
		//Master cumulative clock low extend time more than 10 ms (Tlow:mext)or
		//Slave cumulative clock low extend time more than 25 ms (Tlow:sext)

		//When set in slave mode: slave resets the communication and lines are released by hardware
		//When set in master mode: Stop condition sent by hardware
		pI2CHandle->pI2Cx->SR1 &= ~( 1 << I2C_SR1_TIMEOUT);

		//Implement the code to notify the application about the error
		I2C_ApplicationEventCallback(pI2CHandle,I2C_ERROR_TIMEOUT);
	}
}

void I2C_InterruptHandling_TXECallback(I2C_Handle_t *pI2CHandle)
{
	if(pI2CHandle->TxRxState == I2C_STATE_BUSY_IN_TX)
	{
		if(pI2CHandle->TxLen > 0)
		{
			//send the data
			pI2CHandle->pI2Cx->DR = *(pI2CHandle->pTxBuffer);

			//decrement the length by one byte
			pI2CHandle->TxLen--;

			//increment the buffer address
			pI2CHandle->pTxBuffer++;
		}
	}
}

#if 0
void I2C_InterruptHandling_RXNECallback(I2C_Handle_t *pI2CHandle)
{
	if(pI2CHandle->RxSize == 1 )
	{
		//read the Data byte from DR
		*(pI2CHandle->pRxBuffer) = pI2CHandle->pI2Cx->DR;
#if 0
		//Decrement the Length
		pI2CHandle->RxLen--;
#endif
	}

	if(pI2CHandle->RxSize > 1)
	{
		//Last before 2nd byte
		if(pI2CHandle->RxLen == 2)
		{
			//send the Nack bit
			I2C_ManageACK(pI2CHandle->pI2Cx, DISABLE);
		}
		//read the Data byte from DR
		*(pI2CHandle->pRxBuffer) = pI2CHandle->pI2Cx->DR;

		//Decrement the Length
		pI2CHandle->RxLen--;
		pI2CHandle->pRxBuffer++;
	}
#if 1
	//After sending NACK from the I2C then read the last byte from DR then generate stop condition
	if( pI2CHandle->RxLen == 1 )
	{
		if(pI2CHandle->Repeated_Start == REPEATED_START_DISABLE)
		{
			I2C_StopCondition(pI2CHandle->pI2Cx);
		}
		//Close the I2C reception
		I2C_CloseReception(pI2CHandle);

		I2C_ApplicationEventCallback(pI2CHandle, I2C_APP_EVT_RX_CMPLT);

		//printf(" I2C RX complt...\n");
	}
#endif
	if(pI2CHandle->RxLen == 0)
	{
#if 0
		if(pI2CHandle->Repeated_Start == REPEATED_START_DISABLE)
		{
			I2C_StopCondition(pI2CHandle->pI2Cx);
		}

		//Close the I2C reception
		I2C_CloseReception(pI2CHandle);

		I2C_ApplicationEventCallback(pI2CHandle, I2C_APP_EVT_RX_CMPLT);
		printf(" I2C RX complt...\n");
#endif
	}
}

#endif


#if 0
void I2C_InterruptHandling_RXNECallback(I2C_Handle_t *pI2CHandle)
{
	if(pI2CHandle->RxSize == 1 )
	{
		//read the Data byte from DR
		*(pI2CHandle->pRxBuffer) = pI2CHandle->pI2Cx->DR;
		if(pI2CHandle->Repeated_Start == REPEATED_START_DISABLE)
		{
			I2C_StopCondition(pI2CHandle->pI2Cx);
		}
		pI2CHandle->RxLen--;
	}

	if(pI2CHandle->RxSize > 1)
	{
		//Last before 2nd byte
		if(pI2CHandle->RxLen == 2)
		{
			//send the Nack bit
			I2C_ManageACK(pI2CHandle->pI2Cx, DISABLE);
		}
		//read the Data byte from DR
		*(pI2CHandle->pRxBuffer) = pI2CHandle->pI2Cx->DR;

		//Decrement the Length
		pI2CHandle->RxLen--;
		pI2CHandle->pRxBuffer++;
	}
#if 1
	//After sending NACK from the I2C then read the last byte from DR then generate stop condition
	if( pI2CHandle->RxLen == 1 )
	{
		if(pI2CHandle->Repeated_Start == REPEATED_START_DISABLE)
		{
			I2C_StopCondition(pI2CHandle->pI2Cx);
		}
		//Close the I2C reception
		//I2C_CloseReception(pI2CHandle);

		//I2C_ApplicationEventCallback(pI2CHandle, I2C_APP_EVT_RX_CMPLT);

		//printf(" I2C RX complt...\n");
	}
#endif
	if(pI2CHandle->RxLen == 0)
	{
#if 1
//		if(pI2CHandle->Repeated_Start == REPEATED_START_DISABLE)
//		{
//			I2C_StopCondition(pI2CHandle->pI2Cx);
//		}

		//Close the I2C reception
		I2C_CloseReception(pI2CHandle);

		I2C_ApplicationEventCallback(pI2CHandle, I2C_APP_EVT_RX_CMPLT);
		//printf(" I2C RX complt...\n");
#endif
	}
}
#endif


//As per polling
#if 1
void I2C_InterruptHandling_RXNECallback(I2C_Handle_t *pI2CHandle)
{
	if(pI2CHandle->RxSize == 1 )
	{
		//Generate stop condition and read the data
		if(pI2CHandle->Repeated_Start == REPEATED_START_DISABLE)
		{
			I2C_StopCondition(pI2CHandle->pI2Cx);
		}
		//read the Data byte from DR
		*(pI2CHandle->pRxBuffer) = pI2CHandle->pI2Cx->DR;
#if 1
		//Decrement the Length
		pI2CHandle->RxLen--;
#endif
	}

	if(pI2CHandle->RxSize > 1)
	{
		//Last before 2nd byte
		if(pI2CHandle->RxLen == 2)
		{
			//send the Nack bit
			I2C_ManageACK(pI2CHandle->pI2Cx, DISABLE);

			if(pI2CHandle->Repeated_Start == REPEATED_START_DISABLE)
			{
				I2C_StopCondition(pI2CHandle->pI2Cx);
			}
		}
		//read the Data byte from DR
		*(pI2CHandle->pRxBuffer) = pI2CHandle->pI2Cx->DR;

		//Decrement the Length
		pI2CHandle->RxLen--;
		pI2CHandle->pRxBuffer++;
	}
#if 0
	//After sending NACK from the I2C then read the last byte from DR then generate stop condition
	if( pI2CHandle->RxLen == 1 )
	{
		if(pI2CHandle->Repeated_Start == REPEATED_START_DISABLE)
		{
			I2C_StopCondition(pI2CHandle->pI2Cx);
		}
		//Close the I2C reception
		I2C_CloseReception(pI2CHandle);

		I2C_ApplicationEventCallback(pI2CHandle, I2C_APP_EVT_RX_CMPLT);

		//printf(" I2C RX complt...\n");
	}
#endif
	if(pI2CHandle->RxLen == 0)
	{
#if 1
//		if(pI2CHandle->Repeated_Start == REPEATED_START_DISABLE)
//		{
//			I2C_StopCondition(pI2CHandle->pI2Cx);
//		}

		//Close the I2C reception
		I2C_CloseReception(pI2CHandle);

		I2C_ApplicationEventCallback(pI2CHandle, I2C_APP_EVT_RX_CMPLT);
		printf(" I2C RX complt...\n");
#endif
	}
}

#endif

void I2C_CloseTranmission(I2C_Handle_t *pI2CHandle)
{
	//Clear the TXE and RXNE interrupt
	pI2CHandle->pI2Cx->CR2 &= ~( 1 <<  I2C_CR2_ITBUFEN);
	pI2CHandle->pI2Cx->CR2 &= ~( 1 <<  I2C_CR2_ITEVTEN);

	pI2CHandle->pTxBuffer = NULL;
	pI2CHandle->TxLen = 0;
	pI2CHandle->TxRxState = I2C_STATE_IDLE;
}

void I2C_CloseReception(I2C_Handle_t *pI2CHandle)
{
	pI2CHandle->pI2Cx->CR2 &= ~( 1 <<  I2C_CR2_ITBUFEN);
	pI2CHandle->pI2Cx->CR2 &= ~( 1 <<  I2C_CR2_ITEVTEN);

	pI2CHandle->pRxBuffer = NULL;
	pI2CHandle->RxLen = 0;
	pI2CHandle->TxRxState = I2C_STATE_IDLE;
	pI2CHandle->RxSize = 0;

	if(pI2CHandle->pI2C_Config.I2C_ACKCtrl == I2C_ACK_ENABLE)
	{
		//Re-enable the acking
		I2C_ManageACK(pI2CHandle->pI2Cx, ENABLE);
	}

}


__weak void I2C_ApplicationEventCallback(I2C_Handle_t *pI2CHandle, uint8_t AppEvent)
{

}




void I2C_StartCondition(I2C_RegDef_t *pI2Cx)
{
	pI2Cx->CR1 |= ( 1 << I2C_CR1_START);
}


void I2C_StopCondition(I2C_RegDef_t *pI2Cx)
{
	pI2Cx->CR1 |= ( 1 << I2C_CR1_STOP);
}

/*
 * I2C Get Status API's
 */
uint8_t I2C_GetFlagStatus(I2C_RegDef_t *pI2Cx,uint32_t flagread)
{
	if(pI2Cx->SR1 & flagread)
	{
		return 1;
	}
	return 0;
}


void I2C_ExecuteAddressPhaseWrite(I2C_RegDef_t *pI2Cx,uint8_t SlaveAddress)
{
	uint8_t tempreg = 0;
	tempreg |= ( SlaveAddress << 1);
	tempreg &= ~(1);	// Write operation bit is set in I2C slave address
	pI2Cx->DR = tempreg;
}

void I2C_ExecuteAddressPhaseRead(I2C_RegDef_t *pI2Cx,uint8_t SlaveAddress)
{
	uint8_t tempreg = 0;
	tempreg |= ( SlaveAddress << 1);
	tempreg |= (1 << 0);// Read bit is set in slave address
	pI2Cx->DR = tempreg;
}


void I2C_ClearAddressPhase(I2C_Handle_t *pI2CHandle)
{
	uint8_t tempreg = 0;
	//I2C is in Master Mode
	if(pI2CHandle->pI2Cx->SR2 & (1 << I2C_SR2_MSL))
	{
		if(pI2CHandle->TxRxState ==I2C_STATE_BUSY_IN_RX)
		{
			if(pI2CHandle->RxSize == 1 )
			{
				//Disable the Acking so master wont send ACk bit to slave
				I2C_ManageACK(pI2CHandle->pI2Cx, DISABLE);

				tempreg = pI2CHandle->pI2Cx->SR1;
				tempreg = pI2CHandle->pI2Cx->SR2;
				(void)tempreg;
			}
#if 0
			else // if RXlen has greater than 1 byte
			{
				tempreg = pI2CHandle->pI2Cx->SR1;
				tempreg = pI2CHandle->pI2Cx->SR2;
				(void)tempreg;
			}
#endif
		}
		else // Tx mode
		{
			tempreg = pI2CHandle->pI2Cx->SR1;
			tempreg = pI2CHandle->pI2Cx->SR2;
			(void)tempreg;
		}
	}
	else//I2C is in slave mode
	{
		tempreg = pI2CHandle->pI2Cx->SR1;
		tempreg = pI2CHandle->pI2Cx->SR2;
		(void)tempreg;
	}
}

void I2C_ManageACK(I2C_RegDef_t *pI2Cx,uint8_t EnorDi)
{
	if(EnorDi == ENABLE)
	{
		pI2Cx->CR1 |= (1 << I2C_CR1_ACK);
	}
	else
	{
		pI2Cx->CR1 &= ~(1 << I2C_CR1_ACK);
	}
}

void I2C_DeInit(I2C_RegDef_t *pI2Cx)
{
	if(pI2Cx == I2C1)
	{
		I2C1_REG_RST();
	}
	else if(pI2Cx == I2C2)
	{
		I2C2_REG_RST();
	}
	else if(pI2Cx == I2C3)
	{
		I2C3_REG_RST();
	}
}


void I2C_PeripheralControl(I2C_RegDef_t *pI2Cx,uint8_t EnorDi)
{
	if(EnorDi ==  ENABLE)
	{
		pI2Cx->CR1 |= (1 << I2C_CR1_PE);
	}
	else
	{
		pI2Cx->CR1 &= ~(1 << I2C_CR1_PE);
	}
}




/*
 * SPI IRQ Configuration
 */
void I2C_IRQConfig(uint8_t IRQNumber,uint8_t EnorDi)
{
	if(EnorDi == ENABLE)
	{
		if(IRQNumber <= 31)
		{
			*NVIC_ISER0 |= (1 << IRQNumber);
		}
		else if((IRQNumber > 31) && (IRQNumber < 64))
		{
			*NVIC_ISER1 |= (1 << (IRQNumber % 32));
		}
		else if((IRQNumber >= 64) && (IRQNumber < 96))
		{
			*NVIC_ISER2 |= (1 << (IRQNumber % 64));
		}
	}
	else
	{
		if(IRQNumber <= 31)
		{
			*NVIC_ICER0 |= (1 << IRQNumber);
		}
		else if((IRQNumber > 31) && (IRQNumber < 64))
		{
			*NVIC_ICER1 |= (1 << (IRQNumber % 32));
		}
		else if((IRQNumber >= 64) && (IRQNumber < 96))
		{
			*NVIC_ICER2 |= (1 << (IRQNumber % 64));
		}
	}
}


void I2C_IRQ_PriorityConfig(uint8_t IRQNumber,uint32_t IRQ_Priority)
{
	uint8_t index = 0;
	uint8_t Pos	= 0;
	uint8_t Bit_width = 8;

	index = IRQNumber / 4;
	Pos = IRQNumber % 4;

	*(NVIC_IPRN + index) = ((IRQ_Priority << 4) << (Bit_width * Pos));

}
