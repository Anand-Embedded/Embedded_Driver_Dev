/*
 * stm32f407xx_i2c_driver.c
 *
 *  Created on: Sep 26, 2021
 *      Author: Admin
 */

#include "stm32f4xx.h"

static void I2C_StartCondition(I2C_RegDef_t *pI2Cx);
static void I2C_StopCondition(I2C_RegDef_t *pI2Cx);
static void I2C_AddressPhase(I2C_RegDef_t *pI2Cx,uint8_t SlaveAddress);

/*
 * Peripheral clock enable or disable API
 */
void I2C_PeriClock_Control(I2C_RegDef_t *pI2Cx,uint8_t EnorDi)
{
	if(EnorDi == ENABLE)
	{
		if(pI2Cx == I2C1)
		{
			I2C1_PCLK_EN();
		}
		else if(pI2Cx == I2C2)
		{
			I2C2_PCLK_EN();
		}
		else if(pI2Cx == I2C3)
		{
			I2C3_PCLK_EN();
		}
	}
	else
	{
		if(pI2Cx == I2C1)
		{
			I2C1_PCLK_DI();
		}
		else if(pI2Cx == I2C2)
		{
			I2C2_PCLK_DI();
		}
		else if(pI2Cx == I2C3)
		{
			I2C3_PCLK_DI();
		}
	}
}

uint32_t GetPLLClockOutput(void)
{
	//TODO
}

uint16_t AHB_Prescalar[] = {2,4,8,16,32,64,128,256,512};
uint8_t APB1_Prescalar[] = {2,4,8,16};
uint32_t GetPCLKValue(void)
{
	uint32_t SystemClock = 0;
	uint32_t PCLK = 0;
	uint8_t ClockSource = 0;
	uint8_t AHBprescalarIndex = 0;
	uint8_t APB1prescalarIndex = 0;
	uint16_t AHBPrescValue = 0;
	uint8_t APB1PrescValue = 0;

	ClockSource = (RCC->CFGR >> 2) & 0x03;

	if( ClockSource == 0)
	{
		//HSI
		SystemClock = 16000000;
	}
	else if( ClockSource == 1)
	{
		//HSE
		SystemClock = 8000000;
	}
	else if( ClockSource == 2)
	{
		//PLL
		SystemClock = GetPLLClockOutput();
	}

	AHBprescalarIndex = (RCC->CFGR >> 4) & 0xF;
	if(AHBprescalarIndex == 0)
	{
		AHBPrescValue = 1;
	}
	else
	{
		AHBPrescValue = AHB_Prescalar[AHBprescalarIndex - 8];
	}

	APB1prescalarIndex = (RCC->CFGR >> 10) & 0x7;
	if(APB1prescalarIndex == 0)
	{
		APB1PrescValue = 1;
	}
	else
	{
		APB1PrescValue = APB1_Prescalar[APB1prescalarIndex - 4];
	}

	PCLK = ((SystemClock / AHBPrescValue) / APB1PrescValue) ;

	return PCLK;

}



/*
 * I2Cx init and De-init function
 */
void I2C_Init(I2C_Handle_t *pI2CHandle)
{
	uint32_t tempreg = 0;
	uint32_t APBCLK = 0;

	//Enable the automatic ACKing in I2C hardware
	tempreg |= (pI2CHandle->pI2C_Config.I2C_ACKCtrl << I2C_CR1_ACK);
	pI2CHandle->pI2Cx->CR1 |= tempreg;
	tempreg = 0;

	//Configure the OWN address , this will be used when I2C act as slave
	tempreg |= (pI2CHandle->pI2C_Config.I2C_DeviceAddr << 1);
	tempreg |= (1 << 14);//this is reserved bit and set as per RM
	pI2CHandle->pI2Cx->OAR1 |= tempreg;
	tempreg = 0;

	APBCLK = GetPCLKValue() / 1000000U; //16000000/1000000 =>16

	if(APBCLK <= 1)
	{
		APBCLK = 2;
	}
	//Configure the I2C frequency
	pI2CHandle->pI2Cx->CR2 = (APBCLK & 0x3F);


	if(pI2CHandle->pI2C_Config.I2C_SCLSpeed <= I2C_SPEED_STD_MODE)
	{

		//Sm mode or SMBus:
		//Thigh = CCR * TPCLK1
		//Tlow = CCR * TPCLK1

		tempreg |= (GetPCLKValue() / (2 * pI2CHandle->pI2C_Config.I2C_SCLSpeed));
	}
	else
	{
		//Fast mode
		tempreg |= (1 << I2C_CCR_FS);
		//Configure duty cycle
		tempreg |= (pI2CHandle->pI2C_Config.I2C_FMDutyCycle << I2C_CCR_DUTY);
		//Duty = 0
		if(pI2CHandle->pI2C_Config.I2C_FMDutyCycle == I2C_FM_DUTY_2)
		{
			//Fm mode:
			//If DUTY = 0:
			//Thigh = CCR * TPCLK1
			//Tlow = 2 * CCR * TPCLK1
			//Tlow = 2 * Thigh

			tempreg |= (GetPCLKValue() / (3 * pI2CHandle->pI2C_Config.I2C_SCLSpeed));

		}
		else
		{
			//Duty = 1
			//If DUTY = 1: (to reach 400 kHz)
			//Thigh = 9 * CCR * TPCLK1
			//Tlow = 16 * CCR * TPCLK1
			tempreg |= (GetPCLKValue() / (25 * pI2CHandle->pI2C_Config.I2C_SCLSpeed));
		}
	}
	pI2CHandle->pI2Cx->CCR |= (tempreg & 0xFFF);
	tempreg = 0;
}


/*
 * I2C send and receive data
 */
void I2C_MasterSenddata(I2C_RegDef_t *pI2Cx,uint8_t *pTxBuffer,uint32_t len, uint8_t SlaveAddress)
{
	//Start condition iss generated by master
	I2C_StartCondition(pI2Cx);

	//to clear the start condition event and write the address phase
	while(!(I2C_GetFlagStatus(pI2Cx, I2C_FLAG_SB)));

	I2C_AddressPhase(pI2Cx,SlaveAddress);



}


void I2C_StartCondition(I2C_RegDef_t *pI2Cx)
{
	pI2Cx->CR1 |= ( 1 << I2C_CR1_START);
}


void I2C_StopCondition(I2C_RegDef_t *pI2Cx)
{
	pI2Cx->CR1 |= ( 1 << I2C_CR1_STOP);
}

/*
 * I2C Get Status API's
 */
uint8_t I2C_GetFlagStatus(I2C_RegDef_t *pI2Cx,uint32_t flagread)
{
	if(pI2Cx->SR1 & flagread)
	{
		return 1;
	}
	return 0;
}


void I2C_AddressPhase(I2C_RegDef_t *pI2Cx,uint8_t SlaveAddress)
{
	uint8_t tempreg = 0;
	tempreg |= ( SlaveAddress << 1);
	tempreg = ~(1);
	pI2Cx->DR = tempreg;
}












void I2C_DeInit(I2C_RegDef_t *pI2Cx)
{
	if(pI2Cx == I2C1)
	{
		I2C1_REG_RST();
	}
	else if(pI2Cx == I2C2)
	{
		I2C2_REG_RST();
	}
	else if(pI2Cx == I2C3)
	{
		I2C3_REG_RST();
	}
}


void I2C_PeripheralControl(I2C_RegDef_t *pI2Cx,uint8_t EnorDi)
{
	if(EnorDi ==  ENABLE)
	{
		pI2Cx->CR1 |= (1 << I2C_CR1_PE);
	}
	else
	{
		pI2Cx->CR1 &= ~(1 << I2C_CR1_PE);
	}
}
